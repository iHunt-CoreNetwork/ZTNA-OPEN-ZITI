"use strict";(self.webpackChunkopen_ziti=self.webpackChunkopen_ziti||[]).push([[4554],{3905:(e,r,t)=>{t.d(r,{Zo:()=>d,kt:()=>b});var n=t(67294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function s(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?s(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function a(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=n.createContext({}),l=function(e){var r=n.useContext(c),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},d=function(e){var r=l(e.components);return n.createElement(c.Provider,{value:r},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},h=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,s=e.originalType,c=e.parentName,d=a(e,["components","mdxType","originalType","parentName"]),u=l(t),h=o,b=u["".concat(c,".").concat(h)]||u[h]||p[h]||s;return t?n.createElement(b,i(i({ref:r},d),{},{components:t})):n.createElement(b,i({ref:r},d))}));function b(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var s=t.length,i=new Array(s);i[0]=h;var a={};for(var c in r)hasOwnProperty.call(r,c)&&(a[c]=r[c]);a.originalType=e,a[u]="string"==typeof e?e:o,i[1]=a;for(var l=2;l<s;l++)i[l]=t[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},57926:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var n=t(87462),o=(t(67294),t(3905));const s={title:"Tunneling Kubernetes Workloads",sidebar_label:"Kubernetes"},i=void 0,a={unversionedId:"reference/tunnelers/kubernetes/index",id:"reference/tunnelers/kubernetes/index",title:"Tunneling Kubernetes Workloads",description:"This guide will help you discover the best strategy and tool for connecting a Kubernetes workload. This overview page links to child pages for each strategy and tool, and a summary of each is provided in the sections below. Click on the chart's outcomes to see the corresponding documentation.",source:"@site/docs/reference/tunnelers/80-kubernetes/index.mdx",sourceDirName:"reference/tunnelers/80-kubernetes",slug:"/reference/tunnelers/kubernetes/",permalink:"/docs/reference/tunnelers/kubernetes/",draft:!1,editUrl:"https://github.com/openziti/ziti-doc/tree/main/docusaurus/docs/reference/tunnelers/80-kubernetes/index.mdx",tags:[],version:"current",frontMatter:{title:"Tunneling Kubernetes Workloads",sidebar_label:"Kubernetes"},sidebar:"docsSidebar",previous:{title:"Containers",permalink:"/docs/reference/tunnelers/docker/"},next:{title:"Reverse Proxy Pod",permalink:"/docs/reference/tunnelers/kubernetes/kubernetes-host"}},c={},l=[{value:"Strategies and Solutions",id:"strategies-and-solutions",level:2},{value:"Intercepting Pod Egress",id:"intercepting-pod-egress",level:3},{value:"Transparent Proxy Sidecar",id:"transparent-proxy-sidecar",level:4},{value:"TCP Proxy Sidecar",id:"tcp-proxy-sidecar",level:4},{value:"TCP Proxy Cluster Service",id:"tcp-proxy-cluster-service",level:4},{value:"Ingress to Cluster Services",id:"ingress-to-cluster-services",level:3},{value:"Reverse Proxy Router Pod",id:"reverse-proxy-router-pod",level:4},{value:"NGINX Proxy Module",id:"nginx-proxy-module",level:4},{value:"Reverse Proxy Tunnel Pod",id:"reverse-proxy-tunnel-pod",level:4}],d={toc:l},u="wrapper";function p(e){let{components:r,...t}=e;return(0,o.kt)(u,(0,n.Z)({},d,t,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This guide will help you discover the best strategy and tool for connecting a Kubernetes workload. This overview page links to child pages for each strategy and tool, and a summary of each is provided in the sections below. Click on the chart's outcomes to see the corresponding documentation."),(0,o.kt)("mermaid",{value:'graph TB; \n  A{Pod connects to a service?}\n  A -- Yes --\x3e B{Intercept at pod or </br>cluster level?}\n  subgraph egressGraph ["&nbsp;"]\n    direction BT\n    B -- CLUSTER --\x3e F(["TCP proxy cluster service </br>provides cluster DNS and TCP proxy </br>for each Ziti service"])\n    B -- POD ---\x3e G{Pod uses DNS or </br>static IP to connect to </br>the service?}\n    G -- YES --\x3e H(["tproxy sidecar</br> provides DNS and </br>IP interception to the pod"])\n    G -- NO ---\x3e I(["tcp proxy sidecar</br>binds a local port to </br>each service"])\n  end\n  class egressGraph subgraphClass\n  A -- No --------\x3e K{router </br>is installed?}\n  subgraph ingressGraph ["&nbsp;"]\n    K -- Yes --\x3e J([router reverse proxy </br>provides ingress to</br>cluster services])\n    K -- No ---\x3e C{NGINX </br>is </br>installed?}\n    C -- Yes --\x3e D([NGINX container with </br>proxy module </br>provides ingress to</br>cluster services])\n    C -- No ---\x3e E([reverse proxy tunnel pod</br>provides ingress </br>to cluster services])\n  end\n  click D "#nginx-proxy-module" "NGINX Module"\n  click E "#reverse-proxy-tunnel-pod" "ziti-host"\n  click F "#tcp-proxy-cluster-service" "cluster proxy"\n  click H "#transparent-proxy-sidecar" "transparent sidecar"\n  click I "#tcp-proxy-sidecar" "loopback sidecar"\n  click J "#reverse-proxy-router-pod" "cluster reverse proxy"'}),(0,o.kt)("h2",{id:"strategies-and-solutions"},"Strategies and Solutions"),(0,o.kt)("p",null,"In the chart above, there are several strategies and solutions for connecting a Kubernetes workload. The following sections describe each strategy and solution in more detail. These are organized into two main categories: ingress to cluster services, and intercepting pod egress."),(0,o.kt)("h3",{id:"intercepting-pod-egress"},"Intercepting Pod Egress"),(0,o.kt)("p",null,'An tunneler can be used to intercept pod egress. One important thing to know is that the tunneler that is used in this way may also be used to "host" services in order to provide ingress to cluster services.'),(0,o.kt)("h4",{id:"transparent-proxy-sidecar"},(0,o.kt)("a",{parentName:"h4",href:"/docs/reference/tunnelers/kubernetes/kubernetes-sidecar"},"Transparent Proxy Sidecar")),(0,o.kt)("p",null,"You can deploy a transparent proxy sidecar to intercept pod egress. The sidecar provides a DNS nameserver that is used by the workload application to resolve service addresses. The sidecar container runs ",(0,o.kt)("inlineCode",{parentName:"p"},"ziti tunnel tproxy")," to create IPTables TPROXY rules in the pod. For more information, see the ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/tunnelers/kubernetes/kubernetes-sidecar"},"transparent proxy sidecar")," quickstart."),(0,o.kt)("h4",{id:"tcp-proxy-sidecar"},(0,o.kt)("a",{parentName:"h4",href:"/docs/reference/tunnelers/kubernetes/kubernetes-sidecar"},"TCP Proxy Sidecar")),(0,o.kt)("p",null,"You can deploy a loopback proxy sidecar for pod egress to services. The sidecar binds services to a local port on the pod's loopback interface, e.g., 127.0.0.1:8443. The workload application must be configured to connect to the local port. This mode of operation has a few differences in comparison to the ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/tunnelers/kubernetes/kubernetes-sidecar"},"transparent proxy sidecar")," quickstart."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The sidecar container runs ",(0,o.kt)("inlineCode",{parentName:"li"},"ziti tunnel proxy")," instead of ",(0,o.kt)("inlineCode",{parentName:"li"},"ziti tunnel tproxy"),"."),(0,o.kt)("li",{parentName:"ol"},"The sidecar container does not need the CAP_NET_ADMIN capability."),(0,o.kt)("li",{parentName:"ol"},"The sidecar container does not need a ",(0,o.kt)("inlineCode",{parentName:"li"},"dnsPolicy")," or explicit nameserver.")),(0,o.kt)("h4",{id:"tcp-proxy-cluster-service"},(0,o.kt)("a",{parentName:"h4",href:"/docs/guides/deployments/kubernetes/kubernetes-router"},"TCP Proxy Cluster Service")),(0,o.kt)("p",null,"The router can be deployed to provide a cluster-wide proxy for services, optionally exposing the services' proxy ports with an Ingress or LoadBalancer. This is accomplished by first creating the router with tunnel mode enabled, then deploying the router Helm chart with input values specifying each service for which the router's tunnel identity is authorized by a Dial Service Policy. For more information, see the ",(0,o.kt)("a",{parentName:"p",href:"/docs/guides/deployments/kubernetes/kubernetes-router"},"router")," page. "),(0,o.kt)("h3",{id:"ingress-to-cluster-services"},"Ingress to Cluster Services"),(0,o.kt)("p",null,'Any tunneler can be used to "host" a service. This hosting begins a few moments after a service becomes authorized for the identity in use by the SDK. This section is about different ways to deploy a tunneler to provide ingress to cluster services.'),(0,o.kt)("h4",{id:"reverse-proxy-router-pod"},(0,o.kt)("a",{parentName:"h4",href:"/docs/guides/deployments/kubernetes/kubernetes-router"},"Reverse Proxy Router Pod")),(0,o.kt)("p",null,"The router's built-in tunneler can reverse-proxy cluster services for Ziti clients. This is accomplished by creating the router with tunneler mode enabled, and then installing the router Helm chart with the tunneler mode set to ",(0,o.kt)("inlineCode",{parentName:"p"},"host")," (the default). For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/docs/guides/deployments/kubernetes/kubernetes-router"},"the router")," page."),(0,o.kt)("h4",{id:"nginx-proxy-module"},(0,o.kt)("a",{parentName:"h4",href:"/docs/reference/tunnelers/nginx"},"NGINX Proxy Module")),(0,o.kt)("p",null,"The NGINX Proxy Module can be used to provide ingress to cluster services. The module binds services to an NGINX stream context and forward requests to the configured upstreams. Unlike the rest of these solutions, the NGINX module is not a full tunneler. The main difference for writing configurations for the module is that it will honor the upstreams that are set in the NGINX configuration, ignoring the ",(0,o.kt)("inlineCode",{parentName:"p"},"host.v1")," addresses set in the config. For more information, see the ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/tunnelers/nginx"},"NGINX Proxy Module guide"),"."),(0,o.kt)("h4",{id:"reverse-proxy-tunnel-pod"},(0,o.kt)("a",{parentName:"h4",href:"/docs/reference/tunnelers/kubernetes/kubernetes-host"},"Reverse Proxy Tunnel Pod")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ziti-host")," Helm chart deploys a headless service and can be used to provide ingress cluster services. The pod runs ",(0,o.kt)("inlineCode",{parentName:"p"},"ziti-edge-tunnel run-host")," to bind services and forwards requests arriving via Ziti to their configured host addresses inside the cluster. For more information, see the ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/tunnelers/kubernetes/kubernetes-host"},"ziti-host")," page."))}p.isMDXComponent=!0}}]);